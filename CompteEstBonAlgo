#include "stdafx.h"
#include "LeCompteEstBon.h"
#include "CompteEstBonAlgo.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define CEB_TROUVE 1
#define CEB_NON_TROUVE 0

CompteEstBonAlgo::CompteEstBonAlgo(int nVal1, 
								   int nVal2, 
								   int nVal3, 
								   int nVal4, 
								   int nVal5, 
								   int nVal6, 
								   int nValeur, 
								   CListBox *LB)
{

	m_Plaques.RemoveAll();
	m_Plaques.Add(nVal1);
	m_Plaques.Add(nVal2);
	m_Plaques.Add(nVal3);
	m_Plaques.Add(nVal4);
	m_Plaques.Add(nVal5);
	m_Plaques.Add(nVal6);
	m_Valeur=nValeur;
	m_LB=LB;
	strcpy(m_nom_op, "/x+-");
}

CompteEstBonAlgo::~CompteEstBonAlgo()
{

}



// ***********************************************************************
// resoudre
//
// cette méthode vise à trouver la valeur ValeurATrouver à partir des 
// valeurs transmises (TableauPlaque)
//
// Valeurs de retour :
// CEB_TROUVE		si le résultat escompté a été trouvé 
// CEB_NON_TROUVE	si le résultat escompté n'a pas été trouvé 
// ***********************************************************************
long CompteEstBonAlgo::resoudre( long ValeurATrouver, 
								 long NbElemRestantDansTableau, 
								 long *TableauPlaque) 
{
long v[6], lVal;
int i,j,k,l,op;

	if (NbElemRestantDansTableau<=0)
	{
		// *** ON REMONTE CAR PLUS RIEN A FAIRE***
		return CEB_NON_TROUVE;
	}

    if (NbElemRestantDansTableau==1)
	{
		if (ValeurATrouver==TableauPlaque[0])
		{
			// *** Cas où le reste de la valeur	à trouver ***
			// *** correspond avec la valeur d'une plaque ***
			sprintf(m_res,"Solution : %ld",TableauPlaque[0]);
			m_LB->AddString(m_res);
			// *** ON REMONTE CAR TROUVEE ***
			return CEB_TROUVE;
		}
		else return CEB_NON_TROUVE;
    }

    for (i=0;i<NbElemRestantDansTableau;++i) 
	{
		if (TableauPlaque[i]==ValeurATrouver) 
		{
			printf("Sol : %ld \n",TableauPlaque[i]);
			return CEB_TROUVE;
		}

		for (j=1;j<NbElemRestantDansTableau;++j) 
		{
			if (j==i) continue;
			for (op=0;op<4;++op) 
			{
				switch(op)
				{
					case 0 : v[0]=div(TableauPlaque[i],TableauPlaque[j]);
							 break;
					case 1 : v[0]=mult(TableauPlaque[i],TableauPlaque[j]);
							 break;
					case 2 : v[0]=plus(TableauPlaque[i],TableauPlaque[j]);
							 break;
					case 3 : v[0]=moins(TableauPlaque[i],TableauPlaque[j]);
							 break;
				}
				if (v[0]<0) 
				{
					continue;
				}
				for (k=1,l=0;l<NbElemRestantDansTableau;++l) 
				{
					if (l==i || l==j)
					continue;
					// *** on met chacune des plaques restantes dans le tableau ***
					v[k++]=TableauPlaque[l];
				}
				if (resoudre( ValeurATrouver, NbElemRestantDansTableau-1, v)==1) 
				{
					switch(op)
					{
						case 0 : lVal=div(TableauPlaque[i],TableauPlaque[j]);
								 break;
						case 1 : lVal=mult(TableauPlaque[i],TableauPlaque[j]);
								 break;
						case 2 : lVal=plus(TableauPlaque[i],TableauPlaque[j]);
								 break;
						case 3 : lVal=moins(TableauPlaque[i],TableauPlaque[j]);
								 break;
					}
					sprintf(m_res,"%ld\t= %ld %c %ld", lVal, TableauPlaque[i], m_nom_op[op], TableauPlaque[j]);
					m_LB->AddString(m_res);
					// *** ON REMONTE CAR TROUVEE ***
					return CEB_TROUVE;
				}
			}
		}
    }
    return CEB_NON_TROUVE;
}


// ***********************************************************************
// Calcul
//
// retourne 1 si CEB trouvé 0 sinon
//
// ***********************************************************************
int CompteEstBonAlgo::Calcul()
{
long int t[8];
long int d=0;
int  Valeur;

	// *** On s'assure que le tableau est suffisemment grand ***
	ASSERT(sizeof(t)/sizeof(long int)>=m_Plaques.GetSize());

	for(int i=0; i<m_Plaques.GetSize(); ++i)
		t[i]=m_Plaques.GetAt(i);

	Valeur=m_Valeur;

    while(!resoudre(Valeur, 6, t)) 
	{
        d=-d +( (d>0)?-1:1);
        Valeur+=d;
    }

	return(m_Valeur==Valeur);
}
